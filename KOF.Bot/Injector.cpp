#include "pch.h"
#include "Injector.h"

uint8_t byShellCode[] = 
{
	0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x68, 0x83, 0x7D, 0x08, 0x00, 0x75, 0x0F, 0x8B, 0x45, 
	0x08, 0xC7, 0x40, 0x0C, 0x40, 0x40, 0x40, 0x00, 0xE9, 0xAF, 0x02, 0x00, 0x00, 0x8B, 
	0x4D, 0x08, 0x8B, 0x51, 0x08, 0x89, 0x55, 0xF8, 0x8B, 0x45, 0xF8, 0x8B, 0x48, 0x3C, 
	0x8B, 0x55, 0xF8, 0x8D, 0x44, 0x0A, 0x18, 0x89, 0x45, 0xF0, 0x8B, 0x4D, 0x08, 0x8B, 
	0x11, 0x89, 0x55, 0xBC, 0x8B, 0x45, 0x08, 0x8B, 0x48, 0x04, 0x89, 0x4D, 0xCC, 0x8B, 
	0x55, 0xF0, 0x8B, 0x45, 0xF8, 0x03, 0x42, 0x10, 0x89, 0x45, 0x9C, 0x8B, 0x4D, 0xF0, 
	0x8B, 0x55, 0xF8, 0x2B, 0x51, 0x1C, 0x89, 0x55, 0xD4, 0x0F, 0x84, 0xD9, 0x00, 0x00, 
	0x00, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x6B, 0xC8, 0x05, 0x8B, 0x55, 0xF0, 0x83, 0x7C, 
	0x0A, 0x64, 0x00, 0x0F, 0x84, 0xC3, 0x00, 0x00, 0x00, 0xB8, 0x08, 0x00, 0x00, 0x00, 
	0x6B, 0xC8, 0x05, 0x8B, 0x55, 0xF0, 0x8B, 0x45, 0xF8, 0x03, 0x44, 0x0A, 0x60, 0x89, 
	0x45, 0xF4, 0xB9, 0x08, 0x00, 0x00, 0x00, 0x6B, 0xD1, 0x05, 0x8B, 0x45, 0xF0, 0x8B, 
	0x4D, 0xF4, 0x03, 0x4C, 0x10, 0x64, 0x89, 0x4D, 0xC4, 0x8B, 0x55, 0xF4, 0x3B, 0x55, 
	0xC4, 0x0F, 0x83, 0x8D, 0x00, 0x00, 0x00, 0x8B, 0x45, 0xF4, 0x83, 0x78, 0x04, 0x00, 
	0x0F, 0x84, 0x80, 0x00, 0x00, 0x00, 0x8B, 0x4D, 0xF4, 0x8B, 0x51, 0x04, 0x83, 0xEA, 
	0x08, 0xD1, 0xEA, 0x89, 0x55, 0xC0, 0x8B, 0x45, 0xF4, 0x83, 0xC0, 0x08, 0x89, 0x45, 
	0xDC, 0xC7, 0x45, 0xD8, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x12, 0x8B, 0x4D, 0xD8, 0x83, 
	0xC1, 0x01, 0x89, 0x4D, 0xD8, 0x8B, 0x55, 0xDC, 0x83, 0xC2, 0x02, 0x89, 0x55, 0xDC, 
	0x8B, 0x45, 0xD8, 0x3B, 0x45, 0xC0, 0x74, 0x35, 0x8B, 0x4D, 0xDC, 0x0F, 0xB7, 0x11, 
	0xC1, 0xFA, 0x0C, 0x83, 0xFA, 0x03, 0x75, 0x25, 0x8B, 0x45, 0xF4, 0x8B, 0x4D, 0xF8, 
	0x03, 0x08, 0x8B, 0x55, 0xDC, 0x0F, 0xB7, 0x02, 0x25, 0xFF, 0x0F, 0x00, 0x00, 0x03, 
	0xC8, 0x89, 0x4D, 0xD0, 0x8B, 0x4D, 0xD0, 0x8B, 0x11, 0x03, 0x55, 0xD4, 0x8B, 0x45, 
	0xD0, 0x89, 0x10, 0xEB, 0xB1, 0x8B, 0x4D, 0xF4, 0x8B, 0x55, 0xF4, 0x03, 0x51, 0x04, 
	0x89, 0x55, 0xF4, 0xE9, 0x67, 0xFF, 0xFF, 0xFF, 0xB8, 0x08, 0x00, 0x00, 0x00, 0xC1, 
	0xE0, 0x00, 0x8B, 0x4D, 0xF0, 0x83, 0x7C, 0x01, 0x64, 0x00, 0x0F, 0x84, 0xDE, 0x00, 
	0x00, 0x00, 0xBA, 0x08, 0x00, 0x00, 0x00, 0xC1, 0xE2, 0x00, 0x8B, 0x45, 0xF0, 0x8B, 
	0x4D, 0xF8, 0x03, 0x4C, 0x10, 0x60, 0x89, 0x4D, 0xE8, 0x8B, 0x55, 0xE8, 0x83, 0x7A, 
	0x0C, 0x00, 0x0F, 0x84, 0xBC, 0x00, 0x00, 0x00, 0x8B, 0x45, 0xE8, 0x8B, 0x4D, 0xF8, 
	0x03, 0x48, 0x0C, 0x89, 0x4D, 0xB8, 0x8B, 0x55, 0xBC, 0x89, 0x55, 0xB4, 0x8B, 0x45, 
	0xB8, 0x50, 0xFF, 0x55, 0xB4, 0x89, 0x45, 0xC8, 0x8B, 0x4D, 0xE8, 0x8B, 0x55, 0xF8, 
	0x03, 0x11, 0x89, 0x55, 0xEC, 0x8B, 0x45, 0xE8, 0x8B, 0x4D, 0xF8, 0x03, 0x48, 0x10, 
	0x89, 0x4D, 0xE4, 0x83, 0x7D, 0xEC, 0x00, 0x75, 0x06, 0x8B, 0x55, 0xE4, 0x89, 0x55, 
	0xEC, 0xEB, 0x12, 0x8B, 0x45, 0xEC, 0x83, 0xC0, 0x04, 0x89, 0x45, 0xEC, 0x8B, 0x4D, 
	0xE4, 0x83, 0xC1, 0x04, 0x89, 0x4D, 0xE4, 0x8B, 0x55, 0xEC, 0x83, 0x3A, 0x00, 0x74, 
	0x53, 0x8B, 0x45, 0xEC, 0x8B, 0x08, 0x81, 0xE1, 0x00, 0x00, 0x00, 0x80, 0x74, 0x20, 
	0x8B, 0x55, 0xCC, 0x89, 0x55, 0xB0, 0x8B, 0x45, 0xEC, 0x8B, 0x08, 0x81, 0xE1, 0xFF, 
	0xFF, 0x00, 0x00, 0x51, 0x8B, 0x55, 0xC8, 0x52, 0xFF, 0x55, 0xB0, 0x8B, 0x4D, 0xE4, 
	0x89, 0x01, 0xEB, 0x24, 0x8B, 0x55, 0xEC, 0x8B, 0x45, 0xF8, 0x03, 0x02, 0x89, 0x45, 
	0xAC, 0x8B, 0x4D, 0xCC, 0x89, 0x4D, 0xA8, 0x8B, 0x55, 0xAC, 0x83, 0xC2, 0x02, 0x52, 
	0x8B, 0x45, 0xC8, 0x50, 0xFF, 0x55, 0xA8, 0x8B, 0x4D, 0xE4, 0x89, 0x01, 0xEB, 0x93, 
	0x8B, 0x55, 0xE8, 0x83, 0xC2, 0x14, 0x89, 0x55, 0xE8, 0xE9, 0x37, 0xFF, 0xFF, 0xFF, 
	0xB8, 0x08, 0x00, 0x00, 0x00, 0x6B, 0xC8, 0x09, 0x8B, 0x55, 0xF0, 0x83, 0x7C, 0x0A, 
	0x64, 0x00, 0x74, 0x4C, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x6B, 0xC8, 0x09, 0x8B, 0x55, 
	0xF0, 0x8B, 0x45, 0xF8, 0x03, 0x44, 0x0A, 0x60, 0x89, 0x45, 0xA4, 0x8B, 0x4D, 0xA4, 
	0x8B, 0x51, 0x0C, 0x89, 0x55, 0xE0, 0xEB, 0x09, 0x8B, 0x45, 0xE0, 0x83, 0xC0, 0x04, 
	0x89, 0x45, 0xE0, 0x83, 0x7D, 0xE0, 0x00, 0x74, 0x1D, 0x8B, 0x4D, 0xE0, 0x83, 0x39, 
	0x00, 0x74, 0x15, 0x8B, 0x55, 0xE0, 0x8B, 0x02, 0x89, 0x45, 0xA0, 0x6A, 0x00, 0x6A, 
	0x01, 0x8B, 0x4D, 0xF8, 0x51, 0xFF, 0x55, 0xA0, 0xEB, 0xD4, 0xC6, 0x45, 0xFF, 0x00, 
	0x8B, 0x55, 0x9C, 0x89, 0x55, 0x98, 0x8B, 0x45, 0x08, 0x8B, 0x48, 0x14, 0x51, 0x8B, 
	0x55, 0x08, 0x8B, 0x42, 0x10, 0x50, 0x8B, 0x4D, 0xF8, 0x51, 0xFF, 0x55, 0x98, 0x0F, 
	0xB6, 0x55, 0xFF, 0x85, 0xD2, 0x74, 0x0C, 0x8B, 0x45, 0x08, 0xC7, 0x40, 0x0C, 0x50, 
	0x50, 0x50, 0x00, 0xEB, 0x09, 0x8B, 0x4D, 0x08, 0x8B, 0x55, 0xF8, 0x89, 0x51, 0x0C, 
	0x8B, 0xE5, 0x5D, 0xC2, 0x04, 0x00
};

VitalCode Injection(HANDLE hProc, BYTE* pSrcData, SIZE_T FileSize, DWORD fdwReason, LPVOID lpReserved)
{
	IMAGE_NT_HEADERS* pOldNtHeader = nullptr;
	IMAGE_OPTIONAL_HEADER* pOldOptHeader = nullptr;
	IMAGE_FILE_HEADER* pOldFileHeader = nullptr;
	BYTE* pTargetBase = nullptr;

	if (reinterpret_cast<IMAGE_DOS_HEADER*>(pSrcData)->e_magic != 0x5A4D) //"MZ"
	{ 
#ifdef DEBUG_LOG
		Print("Invalid file");
#endif
		return VITAL_CODE_INJECTION_INVALID_FILE_ERROR;
	}

	pOldNtHeader = reinterpret_cast<IMAGE_NT_HEADERS*>(pSrcData + reinterpret_cast<IMAGE_DOS_HEADER*>(pSrcData)->e_lfanew);
	pOldOptHeader = &pOldNtHeader->OptionalHeader;
	pOldFileHeader = &pOldNtHeader->FileHeader;

	if (pOldFileHeader->Machine != IMAGE_FILE_MACHINE_I386)
	{
#ifdef DEBUG_LOG
		Print("Invalid platform");
#endif
		return VITAL_CODE_INJECTION_INVALID_PLATFORM_ERROR;
	}

	pTargetBase = reinterpret_cast<BYTE*>(VirtualAllocEx(hProc, nullptr, pOldOptHeader->SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));

	if (!pTargetBase) 
	{
#ifdef DEBUG_LOG
		Print("Target process memory allocation failed (ex) 0x%X", GetLastError());
#endif
		return VITAL_CODE_INJECTION_TARGET_PROCESS_MEMORY_ALLOCATION_ERROR;
	}

	DWORD oldp = 0;
	VirtualProtectEx(hProc, pTargetBase, pOldOptHeader->SizeOfImage, PAGE_EXECUTE_READWRITE, &oldp);

	MANUAL_MAPPING_DATA data{ 0 };
	data.pLoadLibraryA = LoadLibraryA;
	data.pGetProcAddress = GetProcAddress;

	data.pbase = pTargetBase;
	data.fdwReasonParam = fdwReason;
	data.reservedParam = lpReserved;
	data.SEHSupport = false;

	if (!WriteProcessMemory(hProc, pTargetBase, pSrcData, 0x1000, nullptr))
	{ 
#ifdef DEBUG_LOG
		Print("Can't write file header 0x%X", GetLastError());
#endif
		VirtualFreeEx(hProc, pTargetBase, 0, MEM_RELEASE);
		return VITAL_CODE_INJECTION_CANT_WRITE_FILE_HEADER_ERROR;
	}

	IMAGE_SECTION_HEADER* pSectionHeader = IMAGE_FIRST_SECTION(pOldNtHeader);
	for (UINT i = 0; i != pOldFileHeader->NumberOfSections; ++i, ++pSectionHeader) 
	{
		if (pSectionHeader->SizeOfRawData) 
		{
			if (!WriteProcessMemory(hProc, pTargetBase + pSectionHeader->VirtualAddress, pSrcData + pSectionHeader->PointerToRawData, pSectionHeader->SizeOfRawData, nullptr)) 
			{
#ifdef DEBUG_LOG
				Print("Can't map sections: 0x%x", GetLastError());
#endif
				VirtualFreeEx(hProc, pTargetBase, 0, MEM_RELEASE);
				return VITAL_CODE_INJECTION_CANT_MAP_SECTIONS_ERROR;
			}
		}
	}

	BYTE* MappingDataAlloc = reinterpret_cast<BYTE*>(VirtualAllocEx(hProc, nullptr, sizeof(MANUAL_MAPPING_DATA), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));

	if (!MappingDataAlloc) 
	{
#ifdef DEBUG_LOG
		Print("Target process mapping allocation failed 0x%X", GetLastError());
#endif
		VirtualFreeEx(hProc, pTargetBase, 0, MEM_RELEASE);
		return VITAL_CODE_INJECTION_TARGET_PROCESS_MAPPING_ALLOCATION_FAILED_ERROR;
	}

	if (!WriteProcessMemory(hProc, MappingDataAlloc, &data, sizeof(MANUAL_MAPPING_DATA), nullptr)) 
	{
#ifdef DEBUG_LOG
		Print("Can't write mapping 0x%X", GetLastError());
#endif
		VirtualFreeEx(hProc, pTargetBase, 0, MEM_RELEASE);
		VirtualFreeEx(hProc, MappingDataAlloc, 0, MEM_RELEASE);
		return VITAL_CODE_INJECTION_CANT_WRITE_MAPPING_ERROR;
	}

	void* pShellcode = VirtualAllocEx(hProc, nullptr, sizeof(byShellCode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	if (!pShellcode) 
	{
#ifdef DEBUG_LOG
		Print("Memory shellcode allocation failed (ex) 0x%X", GetLastError());
#endif
		VirtualFreeEx(hProc, pTargetBase, 0, MEM_RELEASE);
		VirtualFreeEx(hProc, MappingDataAlloc, 0, MEM_RELEASE);
		return VITAL_CODE_INJECTION_MEMORY_SHELLCODE_ALLOCATION_FAILED_ERROR;
	}

	if (!WriteProcessMemory(hProc, pShellcode, &byShellCode, sizeof(byShellCode), nullptr))
	{
#ifdef DEBUG_LOG
		Print("Can't write shellcode 0x%X", GetLastError());
#endif
		VirtualFreeEx(hProc, pTargetBase, 0, MEM_RELEASE);
		VirtualFreeEx(hProc, MappingDataAlloc, 0, MEM_RELEASE);
		VirtualFreeEx(hProc, pShellcode, 0, MEM_RELEASE);
		return VITAL_CODE_INJECTION_CANT_WRITE_SHELLCODE_ERROR;
	}

	HANDLE hThread = CreateRemoteThread(hProc, nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(pShellcode), MappingDataAlloc, 0, nullptr);

	if (!hThread) 
	{
#ifdef DEBUG_LOG
		Print("Thread creation failed 0x%X", GetLastError());
#endif
		VirtualFreeEx(hProc, pTargetBase, 0, MEM_RELEASE);
		VirtualFreeEx(hProc, MappingDataAlloc, 0, MEM_RELEASE);
		VirtualFreeEx(hProc, pShellcode, 0, MEM_RELEASE);
		return VITAL_CODE_INJECTION_THREAD_CREATION_FAILED_ERROR;
	}

	CloseHandle(hThread);

	HINSTANCE hCheck = NULL;

	while (!hCheck) 
	{
		DWORD exitcode = 0;
		GetExitCodeProcess(hProc, &exitcode);

		if (exitcode != STILL_ACTIVE) 
		{
#ifdef DEBUG_LOG
			Print("Process crashed, exit code: %d", exitcode);
#endif
			return VITAL_CODE_INJECTION_PROCESS_CRASHED_ERROR;
		}

		MANUAL_MAPPING_DATA data_checked{ 0 };
		ReadProcessMemory(hProc, MappingDataAlloc, &data_checked, sizeof(data_checked), nullptr);
		hCheck = data_checked.hMod;

		if (hCheck == (HINSTANCE)0x404040) 
		{
#ifdef DEBUG_LOG
			Print("Wrong mapping ptr");
#endif
			VirtualFreeEx(hProc, pTargetBase, 0, MEM_RELEASE);
			VirtualFreeEx(hProc, MappingDataAlloc, 0, MEM_RELEASE);
			VirtualFreeEx(hProc, pShellcode, 0, MEM_RELEASE);
			return VITAL_CODE_INJECTION_WRONG_MAPPING_PTR_ERROR;
		}

		std::this_thread::sleep_for(std::chrono::milliseconds(50));
	}

	BYTE zero_bytes[0x1000]{ 0 };
	if (!WriteProcessMemory(hProc, pTargetBase, zero_bytes, 0x1000, nullptr))
	{
#ifdef DEBUG_LOG
		Print("Can't clear PE HEADER");
#endif
	}

	pSectionHeader = IMAGE_FIRST_SECTION(pOldNtHeader);

	for (UINT i = 0; i != pOldFileHeader->NumberOfSections; ++i, ++pSectionHeader)
	{
		if (pSectionHeader->Misc.VirtualSize)
		{
			if (strcmp((char*)pSectionHeader->Name, ".pdata") == 0 ||
				strcmp((char*)pSectionHeader->Name, ".rsrc") == 0 ||
				strcmp((char*)pSectionHeader->Name, ".reloc") == 0)
			{

				if (!WriteProcessMemory(hProc, pTargetBase + pSectionHeader->VirtualAddress, zero_bytes, pSectionHeader->Misc.VirtualSize, nullptr))
				{
#ifdef DEBUG_LOG
					Print("Can't clear section %s: 0x%x", pSectionHeader->Name, GetLastError());
#endif
				}
			}
		}
	}

	pSectionHeader = IMAGE_FIRST_SECTION(pOldNtHeader);

	for (UINT i = 0; i != pOldFileHeader->NumberOfSections; ++i, ++pSectionHeader)
	{
		if (pSectionHeader->Misc.VirtualSize)
		{
			DWORD old = 0;
			DWORD newP = PAGE_READONLY;

			if ((pSectionHeader->Characteristics & IMAGE_SCN_MEM_WRITE) > 0)
			{
				newP = PAGE_READWRITE;
			}
			else if ((pSectionHeader->Characteristics & IMAGE_SCN_MEM_EXECUTE) > 0)
			{
				newP = PAGE_EXECUTE_READ;
			}

			if (!VirtualProtectEx(hProc, pTargetBase + pSectionHeader->VirtualAddress, pSectionHeader->Misc.VirtualSize, newP, &old))
			{
#ifdef DEBUG_LOG
				Print("Section %s not set as %lX", (char*)pSectionHeader->Name, newP);
#endif
			}
		}
	}

	DWORD old = 0;
	VirtualProtectEx(hProc, pTargetBase, IMAGE_FIRST_SECTION(pOldNtHeader)->VirtualAddress, PAGE_READONLY, &old);

	BYTE clear_bytes[sizeof(pShellcode)]{ 0 };
	if (!WriteProcessMemory(hProc, pShellcode, clear_bytes, sizeof(pShellcode), nullptr))
	{
#ifdef DEBUG_LOG
		Print("Can't clear shellcode");
#endif
	}

	if (!VirtualFreeEx(hProc, pShellcode, 0, MEM_RELEASE)) 
	{
#ifdef DEBUG_LOG
		Print("Can't release shell code memory");
#endif
	}

	if (!VirtualFreeEx(hProc, MappingDataAlloc, 0, MEM_RELEASE)) 
	{
#ifdef DEBUG_LOG
		Print("Can't release mapping data memory");
#endif
	}

	return VITAL_CODE_INJECTION_SUCCESS;
}
